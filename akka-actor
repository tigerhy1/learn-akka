0. actor模型

   actor模型=数据+行为+消息。

   actor模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，
   必须通过消息才能激发行为，这样就保证actor内部数据只有被自己修改。

1. akka里的actor是什么？

   我这里假设你知道什么是线程，actor可以类比线程，但有几个重要的不同点：
   
   1. 比线程轻量:
   
      线程会有stack的消耗, 例如JVM里，默认每个线程会分配ThreadStackSize = 325K,
      导致最多建立几千数量级的线程.
      而你可以建立百万级别的acotr。其中原理就是actor是利用线程池跑的。可以理解actor是虚拟的线程。
      
   2. 通过不可变消息通讯(imutable message):
   
      线程是通过内存通讯的，所以有资源竞争的问题：同一片内存有可能被多线程修改造成数据的不一致。
      而actor把自己内部的状态封装起来（就是外部不可见），而通过不可变的消息实现和外部的通讯。 
      直接屏蔽掉了资源竞争的问题（因为修改和查询都在一个线程中进行）
      
      再也不担心多线程资源竞争问题啦！
      
   也是有相同点的: 就是一个actor同一个时间内只会跑在一个线程上。
   也就是说同一个actor中变量的改变，不会有资源竞争的问题的。
      
      
2. 一个简单的actor的例子

   A, B直接转账的经典例子
   
3. actor实现的原理
  
  一旦理解了actor模型之后，用消息队列+线程池，自己就可以实现actor模型啦！
  每个acotr创建一个消息队列，用于接收这个发给这个actor的消息。
  用线程池中的线程不停的去处理每个actor收到的消息。
  然后注意actor内部的状态对外不可见就可以了(外部可以通过消息改变和读取actor的内部变量和状态)。
  
  还有个有意思的地方，就是akka是怎么调度这些actor的(因为actor的数量很多，轮询的效率太低)，我猜其原理可能跟epoll的模式差不多，
  就是akka可以知道哪些actor收到消息了，然后直接给他们时间片。还有问题，akka对每个actor的权重是否不同
  比如这个actor的queue里的message比较多，会不会给它执行的机会多一点。这涉及到系统的性能。
  
  


